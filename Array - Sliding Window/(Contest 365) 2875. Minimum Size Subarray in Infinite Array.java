/* 2875. Minimum Size Subarray in Infinite Array

You are given a 0-indexed array nums and an integer target.

A 0-indexed array infinite_nums is generated by infinitely appending the elements of nums to itself.

Return the length of the shortest subarray of the array infinite_nums with a sum equal to target. If there is no such subarray return -1.

Example 1:

Input: nums = [1,2,3], target = 5
Output: 2
Explanation: In this example infinite_nums = [1,2,3,1,2,3,1,2,...].
The subarray in the range [1,2], has the sum equal to target = 5 and length = 2.
It can be proven that 2 is the shortest length of a subarray with sum equal to target = 5.

Example 2:

Input: nums = [1,1,1,2,3], target = 4
Output: 2
Explanation: In this example infinite_nums = [1,1,1,2,3,1,1,1,2,3,1,1,...].
The subarray in the range [4,5], has the sum equal to target = 4 and length = 2.
It can be proven that 2 is the shortest length of a subarray with sum equal to target = 4.

Example 3:

Input: nums = [2,4,6,8], target = 3
Output: -1
Explanation: In this example infinite_nums = [2,4,6,8,2,4,6,8,...].
It can be proven that there is no subarray with sum equal to target = 3.
 

Constraints:
1 <= nums.length <= 10^5
1 <= nums[i] <= 10^5
1 <= target <= 10^9
*/

class Solution {
    // 因为是nums是无限循环的，所以 1 <= target <= 10^9的值一定是  n 个nums总和 + 一段子数组的和
    // 所以首先
    // 1.统计nums的总和 ==> 得到剩余子数组需要的和 target % sum(nums)
    // ==> 剩余元素的个数 不会 大于等于 nums.length
    // 2. 滑动窗口来寻找最短的子数组 ==> 不停移动右指针，当滑动窗口的值大于子数组需要的和时，移动左指针
    // 3. ==> 比较得到最短的数组长度
    public int minSizeSubarray(int[] nums, int target) {
        long total = 0;

        //首先计算nums的sum
        for(int num : nums){
            total += num;
        }

        int len = Integer.MAX_VALUE;
        int left = 0;
        int sum = 0; //剩余子数组的和
        int n = nums.length;

        //开始遍历滑动窗口，计算滑动窗口值
        for(int right = 0; right < n * 2; right++){
            //因为剩余的子数组 最多不会超过两个nums，所以要进行 %来对应right在nums中的值
            sum += nums[right % n];
            //然后检查sum是否大于剩余的target值
            while(sum > target % total){
                //如果是的，移动左指针，并且从sum中减去左指针对应的nums值
                sum -= nums[left % n];
                left++;
            }

            //找到了符合target剩余值(target % total) 的 滑动窗口 ==> 计算长度
            if(sum == target % total){
                len = Math.min(len, right - left + 1);
            }
        }

        // 如果没有任何改变，表示不存在这样的子数组，返回-1
        // If there is no such subarray return -1.
        if(len == Integer.MAX_VALUE){
            return -1;
        }

        //如果找到了符合要求的子数组，计算长度 target = n 个nums 总和 + 一段子数组的和
        return len + (int) (target / total) * n; 
        // (target / sum) ==> target中包含几个nums的总和值，然后 * nums长度得到  n 个nums 的长度
    }
}
